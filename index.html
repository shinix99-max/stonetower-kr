<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ëŒíƒ‘ì˜ ë‹¬ì¸ - ì†Œì› ì„±ì·¨</title>
    <!-- ì˜¤í”ˆê·¸ë˜í”„(OG) ë©”íƒ€ íƒœê·¸ ì¶”ê°€ -->
    <meta property="og:title" content="ëŒíƒ‘ì˜ ë‹¬ì¸ - ì†Œì› ì„±ì·¨">
    <meta property="og:description" content="ë‹¹ì‹ ì˜ ì†Œì›ì„ ëŒíƒ‘ì— ë‹´ì•„ë³´ì„¸ìš”.">
    <meta property="og:type" content="website">
    <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/dist/poly-decomp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        :root { --primary: #4a69bd; --bg: #0a0a0a; --text: #f0f2f5; }
        body { margin: 0; padding: 0; overflow: hidden; background: var(--bg); font-family: 'Pretendard', sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; touch-action: none; }
        
        #game-wrapper { 
            position: relative; width: 100%; max-width: 500px; height: 100vh;
            height: calc(var(--vh, 1vh) * 100); background: #0a0a0a; 
            overflow: hidden; display: flex; flex-direction: column;
        }

        @media (min-width: 501px) {
            #game-wrapper { height: 90vh; border-radius: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.8); }
        }
        
        #bg-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center; transition: background-image 1.5s ease-in-out; z-index: 1; opacity: 0.35; }

        .page { position: absolute; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; padding: 20px; box-sizing: border-box; z-index: 10; color: white; text-align: center; }
        .page.active { display: flex; }

        #landing-page { background: linear-gradient(to bottom, #1a1a1a, #0a0a0a); z-index: 60; }
        .landing-illustration {
            position: relative; width: 150px; height: 160px; margin-bottom: 20px;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
        }
        .landing-moon {
            position: absolute; top: 0; width: 60px; height: 60px;
            background: #fdfd96; border-radius: 50%;
            box-shadow: 0 0 30px rgba(253, 253, 150, 0.6);
            z-index: 1;
        }
        .landing-stone {
            width: 100px; height: 40px; border-radius: 50% 50% 40% 40%;
            margin-bottom: -15px; z-index: 2; position: relative;
        }
        .stone-dark { background: #404040; width: 110px; height: 45px; }
        .stone-white { background: #f5f5f5; width: 90px; height: 38px; }
        .stone-gray { background: #707070; width: 100px; height: 42px; }

        .logo { font-size: 42px; font-weight: 900; margin-bottom: 10px; color: #f5f5f5; text-shadow: 0 0 20px rgba(255,255,255,0.2); }
        .sub-logo { font-size: 16px; color: #ccc; margin-bottom: 40px; }
        .input-group { width: 80%; display: flex; flex-direction: column; gap: 15px; }
        input#nickname { padding: 18px; border-radius: 15px; border: 2px solid #333; background: #1a1a1a; color: white; font-size: 18px; text-align: center; outline: none; }
        .start-btn { background: var(--primary); color: white; padding: 18px; border-radius: 15px; border: none; font-weight: bold; font-size: 18px; cursor: pointer; }

        #game-page { padding: 0; cursor: default; background: transparent; overflow: hidden; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; }
        
        #wish-btn { 
            position: absolute; top: 30px; right: 30px; 
            background: linear-gradient(135deg, #ffd700, #b8860b);
            border: 2px solid #fff;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            color: white; padding: 10px 22px; border-radius: 25px; 
            font-weight: 800; cursor: pointer; z-index: 30; backdrop-filter: blur(5px);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            animation: glow 2s infinite alternate;
        }
        @keyframes glow {
            from { box-shadow: 0 0 10px rgba(255, 215, 0, 0.4), inset 0 0 5px rgba(255,255,255,0.2); }
            to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), inset 0 0 10px rgba(255,255,255,0.4); }
        }

        #info { position: absolute; top: 30px; left: 30px; pointer-events: none; z-index: 20; text-align: left; }
        .stats { font-size: 20px; font-weight: 800; color: white; text-shadow: 0 2px 5px rgba(0,0,0,0.7); }
        .guide-text { position: absolute; bottom: 50px; width: 100%; text-align: center; color: rgba(255,255,255,0.8); font-size: 15px; font-weight: 500; pointer-events: none; z-index: 20; text-shadow: 0 1px 2px rgba(0,0,0,0.4); }

        #wish-page { background: rgba(10, 10, 10, 0.9); z-index: 70; }
        textarea#wish-text { width: 90%; height: 72px; padding: 20px; border-radius: 20px; border: 2px solid #333; background: #1a1a1a; color: white; margin-bottom: 30px; resize: none; font-size: 18px; outline: none; box-sizing: border-box; }
        .submit-wish-btn { background: var(--primary); color: white; padding: 18px 40px; border-radius: 15px; border: none; font-weight: bold; font-size: 18px; cursor: pointer; width: 90%; }

        #result-page { background: #0a0a0a; overflow-y: auto; justify-content: flex-start; padding-top: 40px; padding-bottom: 60px; }
        #result-page.active { display: block; }
        .screenshot-container { width: 95%; height: auto; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); margin: 0 auto 20px auto; border: 1px solid #333; background: #1a1a1a; overflow: hidden; }
        #final-screenshot { width: 100%; height: auto; display: block; }
        .cheer-msg { font-size: 20px; font-weight: 700; margin-bottom: 30px; color: #ddd; }
        
        .retry-btn { 
            background: var(--primary); color: white; padding: 20px 40px; 
            border-radius: 15px; border: none; font-weight: 800; font-size: 22px; 
            cursor: pointer; width: 90%; margin: 20px auto 40px auto; display: block;
            box-shadow: 0 5px 15px rgba(74, 105, 189, 0.4);
            transition: transform 0.2s;
        }
        .retry-btn:active { transform: scale(0.98); }

        .leaderboard { width: 95%; height: auto; min-height: 40vh; background: #1a1a1a; border-radius: 20px; padding: 15px; margin: 0 auto 40px auto; border: 1px solid #333; box-sizing: border-box; }
        .leaderboard h3 { margin-top: 0; margin-bottom: 15px; font-size: 18px; color: #ffd700; }
        .rank-table { width: 100%; border-collapse: collapse; font-size: 15px; }
        .rank-table th { padding: 10px; border-bottom: 2px solid #333; color: #888; font-weight: 500; }
        .rank-table td { padding: 12px 8px; border-bottom: 1px solid #222; }
        .rank-item.my-rank { outline: 2px solid #3498db; border-radius: 10px; background: rgba(52, 152, 219, 0.1); }
        .rank-medal { font-size: 20px; }

        #start-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.7); z-index: 25; cursor: pointer; }
        .start-text { font-size: 32px; font-weight: bold; color: white; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.05); opacity: 1; } 100% { transform: scale(1); opacity: 0.8; } }

        #moon-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.5); z-index: 100; pointer-events: none; }
        .moon-icon { font-size: 100px; filter: drop-shadow(0 0 30px rgba(255, 255, 200, 0.9)); transform: translateY(150px); opacity: 0; transition: all 2.5s cubic-bezier(0.25, 0.1, 0.25, 1); }
        .moon-icon.rising { transform: translateY(-100px); opacity: 1; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="bg-layer"></div>

    <section id="landing-page" class="page active">
        <div class="landing-illustration">
            <div class="landing-moon"></div>
            <div class="landing-stone stone-white" style="z-index: 4;"></div>
            <div class="landing-stone stone-gray" style="z-index: 3;"></div>
            <div class="landing-stone stone-dark" style="z-index: 2;"></div>
        </div>
        <h1 class="logo">ëŒíƒ‘ì˜ ë‹¬ì¸</h1>
        <p class="sub-logo">ë‹¹ì‹ ì˜ ì†Œì›ì„ ëŒíƒ‘ì— ë‹´ì•„ë³´ì„¸ìš”.</p>
        <p style="font-size: 14px; color: #aaa; margin-top: -28px; margin-bottom: 28px;">ì§€ê¸ˆê¹Œì§€ <span id="total-towers">0</span>ê°œì˜ ëŒíƒ‘ì´ ìŒ“ì˜€ì–´ìš”</p>
        <div class="input-group">
            <input type="text" id="nickname" placeholder="ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
            <button class="start-btn" onclick="goToGame()">ì‹œì‘í•˜ê¸°</button>
        </div>
    </section>

    <section id="game-page" class="page">
        <div id="moon-overlay">
            <div class="moon-icon">ğŸŒ•</div>
        </div>
        <button id="wish-btn" onclick="goToWish()">ì†Œì› ë¹Œê¸°</button>
        <div id="info">
            <div class="stats"><span id="user-nickname-display">ìœ ì €</span>ë‹˜ì˜ ëŒíƒ‘</div>
            <div class="stats"><span id="count">1</span>ì¸µ</div>
        </div>
        <div id="start-overlay" onclick="startGame(event)">
            <div class="start-text">í„°ì¹˜í•˜ì—¬ ì‹œì‘</div>
            <p style="font-size: 16px; color: #fff; margin-top: 20px; font-weight: bold;">ì›í•˜ëŠ” ìœ„ì¹˜ë¡œ ëŒì–´ì„œ ë†“ìœ¼ì„¸ìš”.</p>
            <p style="font-size: 14px; color: #aaa; margin-top: 10px;">* ì†Œì› ë¹Œê¸°ë¥¼ ëˆ„ë¥´ë©´ ë‹¤ì‹œ ìŒ“ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
        <div id="canvas-container"></div>
    </section>

    <section id="wish-page" class="page">
        <h2>ì†Œì› ì ê¸°</h2>
        <textarea id="wish-text" placeholder="ì—¬ê¸°ì— ì†Œì›ì„ ì ì–´ì£¼ì„¸ìš”..."></textarea>
        <button class="submit-wish-btn" onclick="finishGame()">ì†Œì› ì €ì¥í•˜ê³  ê²°ê³¼ ë³´ê¸°</button>
    </section>

    <section id="result-page" class="page">
        <div class="screenshot-container">
            <img id="final-screenshot" src="" alt="ë‚˜ì˜ ëŒíƒ‘">
        </div>
        <p class="cheer-msg">ë‹¹ì‹ ì˜ ì†Œì›ì´<br>ê¼­ ì´ë¤„ì§€ê¸¸ ë°”ë¼ê² ëŒğŸª¨<br><br><span style="font-size: 16px; opacity: 0.8;">- ëŒíƒ‘ êµ¬ì„±ì› ì¼ë™ -</span></p>
        <button class="retry-btn" onclick="location.reload()">ìƒˆ ëŒíƒ‘ ìŒ“ê¸°</button>
        <div class="leaderboard">
            <h3>ëŒíƒ‘ ë‹¬ì¸ ë­í‚¹</h3>
            <div id="leaderboard-list"></div>
        </div>
    </section>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Body, Events, Bounds, Vertices, SAT, Query, Common } = Matter;

    // Supabase ì„¤ì •
    const SUPABASE_URL = 'https://getubkgxtccbmxypwkui.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdldHVia2d4dGNjYm14eXB3a3VpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjcwODMwNTcsImV4cCI6MjA4MjY1OTA1N30.GiGrkY1V27PluiWG6BL7dNLOK4U-XJruq0SDl1dV5Ho';
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    let currentSessionId = null; // í˜„ì¬ íŒì˜ DB IDë¥¼ ì €ì¥

    const BG_IMAGES = {
        level1: 'url("./low_background_3.png")', 
        level2: 'url("./middle_background_3.png")', 
        level3: 'url("./high_background_3.png")'   
    };

    const SHAPE_TEMPLATES = [
        [{x: -0.55, y: 0}, {x: -0.5, y: -0.15}, {x: -0.3, y: -0.22}, {x: 0, y: -0.25}, {x: 0.3, y: -0.22}, {x: 0.5, y: -0.15}, {x: 0.55, y: 0}, {x: 0.5, y: 0.15}, {x: 0.3, y: 0.22}, {x: 0, y: 0.25}, {x: -0.3, y: 0.22}, {x: -0.5, y: 0.15}, {x: -0.55, y: 0.05}],
        [{x: -0.45, y: 0}, {x: -0.4, y: -0.18}, {x: -0.1, y: -0.25}, {x: 0.2, y: -0.24}, {x: 0.5, y: -0.15}, {x: 0.55, y: 0.05}, {x: 0.45, y: 0.2}, {x: 0.1, y: 0.25}, {x: -0.2, y: 0.23}, {x: -0.4, y: 0.15}],
        [{x: -0.4, y: 0.05}, {x: -0.35, y: -0.15}, {x: -0.15, y: -0.23}, {x: 0.15, y: -0.23}, {x: 0.35, y: -0.15}, {x: 0.4, y: 0.05}, {x: 0.35, y: 0.22}, {x: 0.1, y: 0.25}, {x: -0.1, y: 0.25}, {x: -0.35, y: 0.22}],
        [{x: -0.5, y: 0.05}, {x: -0.45, y: -0.12}, {x: -0.1, y: -0.25}, {x: 0.3, y: -0.22}, {x: 0.52, y: -0.05}, {x: 0.48, y: 0.18}, {x: 0.2, y: 0.25}, {x: -0.15, y: 0.24}, {x: -0.4, y: 0.18}],
        [{x: -0.58, y: -0.05}, {x: -0.5, y: -0.22}, {x: 0, y: -0.25}, {x: 0.5, y: -0.22}, {x: 0.58, y: -0.05}, {x: 0.55, y: 0.18}, {x: 0, y: 0.25}, {x: -0.55, y: 0.18}]
    ];

    let engine, render, runner, ground, baseStone;
    let nickname = ""; let stoneCount = 0;
    let isGameOver = false; let isGameStarted = false; let stones = [];
    let isPressing = false; let isValidLocation = true;    
    let initialTouchX = 0; let initialTouchY = 0;
    let initialStoneX = 0; let initialStoneY = 0;
    let cameraY = 0; let targetCameraY = 0;
    let gameWidth = 450; let gameHeight = 800;
    let nextStoneData = { w: 0, h: 0 };
    let currentInputPos = { x: 225, y: 320 };
    let isWishFlow = false; // ì†Œì› ë¹Œê¸° ì´í›„: ê²Œì„ ì…ë ¥(í„°ì¹˜) ì°¨ë‹¨ìš©

    // ì „ì—­ í•¨ìˆ˜ ë“±ë¡
    window.showPage = (id) => {
        document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
        document.getElementById(id).classList.add('active');
    };

    window.goToGame = () => {
        const input = document.getElementById('nickname');
        if (!input.value.trim()) { alert("ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!"); return; }
        nickname = input.value.trim();
        document.getElementById('user-nickname-display').textContent = nickname;
        window.showPage('game-page');
    };

    window.startGame = async (e) => {
        if (e) { e.stopPropagation(); e.preventDefault(); }
        if (isGameStarted) return;
        isGameStarted = true;
        document.getElementById('start-overlay').style.display = 'none';
        
        // [Supabase] ê¸°ë°˜ì„ ë“œë¡­(ê²Œì„ ì‹œì‘) íšŸìˆ˜ ì§‘ê³„ ë° ì„¸ì…˜ ì‹œì‘
        try {
            const { data: trials } = await supabaseClient
                .from('stone_towers')
                .select('trial')
                .eq('nickname', nickname)
                .order('trial', { ascending: false })
                .limit(1);
            
            const nextTrial = (trials && trials.length > 0) ? trials[0].trial + 1 : 1;
            
            // ì´ˆê¸° floorëŠ” 1, is_wishëŠ” 0(ì§„í–‰ì¤‘/ì‹¤íŒ¨)ìœ¼ë¡œ ì‹œì‘
            const { data } = await supabaseClient
                .from('stone_towers')
                .insert([{ nickname, trial: nextTrial, floor: 1, is_wish: 0 }])
                .select();
            
            if (data && data.length > 0) currentSessionId = data[0].id;
            loadGlobalStats();
        } catch (err) {}

        Body.setStatic(baseStone, false);
        prepareNextStone();
    };

    window.goToWish = async () => {
        isWishFlow = true;
        isPressing = false;
        const btn = document.getElementById('wish-btn');
        if (btn) { btn.disabled = true; btn.style.opacity = '0.5'; }
        
        const moon = document.getElementById('moon-overlay');
        if (moon) {
            moon.style.display = 'flex';
            setTimeout(() => moon.querySelector('.moon-icon').classList.add('rising'), 50);
        }

        // í˜ì´ì§€ ì „í™˜ì„ ë¨¼ì € ì§„í–‰í•˜ì—¬ ì‚¬ìš©ì ì²´ê° ê°œì„ 
        setTimeout(() => {
            window.showPage('wish-page');
            captureFinalTower(); // ìº¡ì²˜ëŠ” ë°°ê²½ì—ì„œ ì§„í–‰
        }, 2500);
    };

    window.finishGame = () => {
        if (!document.getElementById('wish-text').value.trim()) { alert("ì†Œì›ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!"); return; }
        renderLeaderboard(); window.showPage('result-page');
    };

    function captureFinalTower() {
        const bgLayer = document.getElementById('bg-layer');
        const finalImg = document.getElementById('final-screenshot');
        if (!finalImg || stones.length === 0) return;

        // 1. ì „ì²´ ëŒíƒ‘ì˜ ë²”ìœ„ ê³„ì‚° (ìµœìƒë‹¨ ëŒë¶€í„° ê¸°ë°˜ì„ ë°”ë‹¥ê¹Œì§€)
        const currentBOffset = (window.innerWidth <= 500) ? 120 : 100;
        const towerBottomY = gameHeight - currentBOffset + 25; // ê¸°ë°˜ì„ ì•„ë«ë©´
        
        let minTopY = towerBottomY;
        stones.forEach(s => { if (s.bounds.min.y < minTopY) minTopY = s.bounds.min.y; });
        
        const totalTowerHeight = towerBottomY - minTopY + 40; // ìƒë‹¨ ì—¬ë°± ìµœì†Œí™”
        const captureWidth = gameWidth;
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = captureWidth; tempCanvas.height = totalTowerHeight;
        const ctx = tempCanvas.getContext('2d');

        const bgUrl = bgLayer.style.backgroundImage.replace(/url\(['"]?(.*?)['"]?\)/i, '$1');

        const renderTower = (bg) => {
            ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // ë°°ê²½ ê·¸ë¦¬ê¸°
            if (bg) {
                ctx.save(); ctx.globalAlpha = 0.25;
                const scale = Math.max(tempCanvas.width / bg.width, tempCanvas.height / bg.height);
                ctx.drawImage(bg, (tempCanvas.width - bg.width*scale)/2, (tempCanvas.height - bg.height*scale)/2, bg.width*scale, bg.height*scale);
                ctx.restore();
            }

            // ëª¨ë“  ëŒ ê·¸ë¦¬ê¸° (Yì¢Œí‘œ ë³´ì •: towerBottomYê°€ tempCanvas.heightì— ë‹¿ë„ë¡)
            const offsetY = tempCanvas.height - towerBottomY;
            ctx.save(); ctx.translate(0, offsetY);
            
            // ë°”ë‹¥ ë°ì½”ëŠ” ìŠ¤í¬ë¦°ìƒ·ì—ì„œ ì œì™¸í•˜ê±°ë‚˜ ìµœì†Œí™” (ëŒíƒ‘ì— ì§‘ì¤‘)
            
            // ëŒíƒ‘ êµ¬ì„±ì›ë“¤
            [ground, ...stones].forEach(body => {
                const { x, y } = body.position;
                ctx.save();
                ctx.fillStyle = (body.render.fillStyle === 'rainbow') ? '#ffcc00' : body.render.fillStyle;
                (body.parts.length > 1 ? body.parts.slice(1) : [body]).forEach(p => {
                    ctx.beginPath(); p.vertices.forEach((v, i) => i === 0 ? ctx.moveTo(v.x, v.y) : ctx.lineTo(v.x, v.y)); ctx.closePath(); ctx.fill();
                });
                if (body.patternType && body.patternType !== 'rainbow') {
                    ctx.save(); ctx.translate(x, y); ctx.rotate(body.angle); ctx.beginPath();
                    (body.parts.length > 1 ? body.parts[1].vertices : body.vertices).forEach((v, i) => { const lx = v.x-x, ly = v.y-y, cos = Math.cos(-body.angle), sin = Math.sin(-body.angle); i === 0 ? ctx.moveTo(lx*cos-ly*sin, lx*sin+ly*cos) : ctx.lineTo(lx*cos-ly*sin, lx*sin+ly*cos); });
                    ctx.closePath(); ctx.clip(); drawStonePattern(ctx, body.patternType, body.patternSeed, body.bounds.max.x-body.bounds.min.x, body.bounds.max.y-body.bounds.min.y); ctx.restore();
                }
                ctx.restore();
                if (body.label !== 'ground') {
                    ctx.save(); ctx.translate(x, y); ctx.rotate(body.angle);
                    ctx.fillStyle = body.render.fillStyle === 'rainbow' ? '#fff' : (body.render.fillStyle === '#404040' || body.render.fillStyle === '#707070' ? '#ddd' : '#333');
                    ctx.textAlign = 'center'; ctx.font = 'bold 20px Arial'; ctx.fillText(body.emojiPair ? (body.speed < 0.3 ? body.emojiPair.stable : body.emojiPair.unstable) : 'â—â—¡â—', 0, 5); ctx.restore();
                }
            });
            ctx.restore();
            
            finalImg.src = tempCanvas.toDataURL('image/png');
        };

        if (bgUrl && bgUrl !== 'none') {
            const img = new Image(); img.crossOrigin = "anonymous";
            img.onload = () => renderTower(img); img.onerror = () => renderTower(null); img.src = bgUrl;
        } else renderTower(null);
    }

    function initPhysics() {
        const container = document.getElementById('canvas-container');
        const isMobile = window.innerWidth <= 500;
        gameWidth = isMobile ? window.innerWidth : 500;
        gameHeight = isMobile ? window.innerHeight : window.innerHeight * 0.9;
        engine = Engine.create({ constraintIterations: 50, positionIterations: 50, velocityIterations: 50 });
        engine.world.gravity.y = 1.2;
        render = Render.create({ element: container, engine, options: { width: gameWidth, height: gameHeight, wireframes: false, background: 'transparent', hasBounds: true } });
        
        // [ìˆ˜ì •] ë°”ë‹¥ íšŒìƒ‰ ì˜ì—­ ë†’ì´ë¥¼ ë‹¤ì‹œ ì¤„ì„ (200/150 -> 120/100)
        const bOffset = isMobile ? 120 : 100;
        ground = Bodies.rectangle(gameWidth / 2, gameHeight + 50 - (bOffset - 25), gameWidth, bOffset + 100, { isStatic: true, label: 'ground', render: { fillStyle: '#333' } });
        baseStone = Bodies.rectangle(gameWidth / 2, -50, 160, 50, { friction: 10, frictionStatic: 1000, density: 200, chamfer: { radius: 25 }, label: 'baseStone', isStatic: true, emojiPair: { stable: "â—â—¡â—", unstable: "âŠ™ï½âŠ™" }, render: { fillStyle: '#dcdcdc' } });
        stones.push(baseStone); Composite.add(engine.world, [ground, baseStone]);
        
        Events.on(render, 'beforeRender', () => { cameraY += (targetCameraY - cameraY) * 0.05; Bounds.shift(render.bounds, { x: 0, y: cameraY }); });
        Events.on(render, 'afterRender', () => {
            const ctx = render.context; const now = Date.now();
            ctx.save(); ctx.translate(-render.bounds.min.x, -render.bounds.min.y);

            // 1. í•˜ë‹¨ íšŒìƒ‰ ì˜ì—­ ë°ì½”ë ˆì´ì…˜ (ëŒ ìŒ“ì¸ í˜•ìƒ)
            groundDeco.forEach(deco => {
                ctx.save(); ctx.translate(deco.x, deco.y); ctx.rotate(deco.angle);
                ctx.fillStyle = deco.color;
                ctx.beginPath(); deco.vertices.forEach((v, i) => i === 0 ? ctx.moveTo(v.x, v.y) : ctx.lineTo(v.x, v.y)); ctx.closePath(); ctx.fill();
                // íŒ¨í„´
                ctx.save(); ctx.clip(); drawStonePattern(ctx, deco.pattern, deco.seed, deco.w, deco.h); ctx.restore();
                // í…Œë‘ë¦¬ ì¶”ê°€ë¡œ ë” ì„ ëª…í•˜ê²Œ
                ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1; ctx.stroke();
                ctx.restore();
            });

            // 2. í„°ì¹˜ ì „ ëŒ€ê°•ì˜ ì ì„  íƒ€ì› ê°€ì´ë“œ
            if (isGameStarted && !isGameOver && !isPressing && !isWishFlow && stones.filter(s => !s.isStatic).length === 0) {
                ctx.save(); ctx.translate(currentInputPos.x, currentInputPos.y);
                ctx.setLineDash([5, 5]); ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth = 2;
                ctx.beginPath(); nextStoneData.vertices.forEach((v, i) => i === 0 ? ctx.moveTo(v.x, v.y) : ctx.lineTo(v.x, v.y)); ctx.closePath(); ctx.stroke();
                ctx.restore();
            }

            if (isGameStarted && !isGameOver && isPressing && stones.filter(s => !s.isStatic).length === 0) {
                ctx.save(); ctx.translate(currentInputPos.x, currentInputPos.y); ctx.globalAlpha = 0.6; ctx.fillStyle = isValidLocation ? '#f5f5f5' : '#ff7675';
                ctx.beginPath(); nextStoneData.vertices.forEach((v, i) => i === 0 ? ctx.moveTo(v.x, v.y) : ctx.lineTo(v.x, v.y)); ctx.closePath(); ctx.fill();
                if (nextStoneData.pattern) { ctx.save(); ctx.clip(); drawStonePattern(ctx, nextStoneData.pattern, nextStoneData.seed, nextStoneData.w, nextStoneData.h); ctx.restore(); }
                ctx.fillStyle = '#333'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.fillText(nextStoneData.emojiPair.stable, 0, 5);
                ctx.globalAlpha = 1; ctx.font = '35px Arial'; ctx.fillText('ğŸ‘†', nextStoneData.w / 2, 20); ctx.restore();
            }
            [ground, ...stones].forEach(body => {
                const { x, y } = body.position;
                const currentBOffset = (window.innerWidth <= 500) ? 120 : 100;
                const stopY = gameHeight - currentBOffset;
                if (body.label === 'baseStone' && !body.isStatic && y >= stopY) { Body.setStatic(body, true); Body.setPosition(body, { x: gameWidth / 2, y: stopY }); }
                if (!body.isStatic) { if (body.speed < 0.3 && body.angularSpeed < 0.05) { if (!body.stableStartTime) body.stableStartTime = now; else if (now - body.stableStartTime > 600) Body.setStatic(body, true); } else body.stableStartTime = null; }
                ctx.save();
                if (body.render.fillStyle === 'rainbow') { const h = (now / 30) % 360; ctx.fillStyle = `hsl(${h}, 80%, 70%)`; ctx.shadowColor = `hsl(${h}, 80%, 70%)`; ctx.shadowBlur = 15; }
                else ctx.fillStyle = body.render.fillStyle;
                (body.parts.length > 1 ? body.parts.slice(1) : [body]).forEach(p => { 
                    ctx.beginPath(); p.vertices.forEach((v, i) => i === 0 ? ctx.moveTo(v.x, v.y) : ctx.lineTo(v.x, v.y)); ctx.closePath(); ctx.fill(); 
                });
                if (body.patternType && body.patternType !== 'rainbow') {
                    ctx.save(); ctx.translate(x, y); ctx.rotate(body.angle); ctx.beginPath();
                    (body.parts.length > 1 ? body.parts[1].vertices : body.vertices).forEach((v, i) => { const lx = v.x-x, ly = v.y-y, cos = Math.cos(-body.angle), sin = Math.sin(-body.angle); i === 0 ? ctx.moveTo(lx*cos-ly*sin, lx*sin+ly*cos) : ctx.lineTo(lx*cos-ly*sin, lx*sin+ly*cos); });
                    ctx.closePath(); ctx.clip(); drawStonePattern(ctx, body.patternType, body.patternSeed, body.bounds.max.x-body.bounds.min.x, body.bounds.max.y-body.bounds.min.y); ctx.restore();
                }
                ctx.restore();
                if (body.label !== 'ground') {
                    ctx.save(); ctx.translate(x, y); ctx.rotate(body.angle);
                    ctx.fillStyle = body.render.fillStyle === 'rainbow' ? '#fff' : (body.render.fillStyle === '#404040' || body.render.fillStyle === '#707070' ? '#ddd' : '#333');
                    ctx.textAlign = 'center'; ctx.font = 'bold 20px Arial'; ctx.fillText(body.emojiPair ? (body.speed < 0.3 ? body.emojiPair.stable : body.emojiPair.unstable) : 'â—â—¡â—', 0, 5); ctx.restore();
                }
            });
            ctx.restore();
        });
        Events.on(engine, 'collisionStart', (e) => { e.pairs.forEach(p => { if (((stones.includes(p.bodyA) && !p.bodyA.isStatic) || (stones.includes(p.bodyB) && !p.bodyB.isStatic)) && p.bodyA !== ground && p.bodyB !== ground && p.bodyA.label !== 'baseStone' && p.bodyB.label !== 'baseStone') stones.forEach(s => { if(s.isStatic && s.label !== 'baseStone') Body.setStatic(s, false); }); if ((p.bodyA === ground || p.bodyB === ground) && !isGameOver && (p.bodyA.label === 'stone' || p.bodyB.label === 'stone')) gameOver(); }); });
        runner = Runner.create(); Runner.run(runner, engine); Render.run(render);
    }

    function checkValidity() {
        const temp = Bodies.fromVertices(currentInputPos.x, currentInputPos.y, [nextStoneData.vertices.map(v => ({ x: v.x + currentInputPos.x, y: v.y + currentInputPos.y }))]);
        if (!temp) { isValidLocation = true; return; }
        isValidLocation = !Query.region(stones, temp.bounds).some(o => SAT.collides(temp, o).collided);
    }

    function dropStone() {
        const r = Math.random(); const c = r < 0.24 ? '#f5f5f5' : (r < 0.48 ? '#b0b0b0' : (r < 0.72 ? '#707070' : (r < 0.95 ? '#404040' : 'rainbow')));
        const s = Bodies.fromVertices(currentInputPos.x, currentInputPos.y, [Vertices.create(nextStoneData.vertices)], { friction: 10, frictionStatic: 1000, restitution: 0, density: 100, label: 'stone', patternType: nextStoneData.pattern, patternSeed: nextStoneData.seed, emojiPair: c === 'rainbow' ? { stable: 'âœª Ï‰ âœª', unstable: 'âœª Ï‰ âœª' } : nextStoneData.emojiPair, render: { fillStyle: c, visible: false } }, true, 0.01, 10, 0.01);
        if (!s) return; stones.push(s); Composite.add(engine.world, s); stoneCount++; document.getElementById('count').textContent = stoneCount + 1; updateEnvironment(stoneCount + 1); prepareNextStone();
    }

    function gameOver() { 
        if (isGameOver) return; 
        isGameOver = true; 
        isPressing = false; 

        // [Supabase] ë¬´ë„ˆì¡Œì„ ë•Œì˜ ìµœì¢… ì¸µìˆ˜ ê¸°ë¡ (ê¸°ë°˜ì„ í¬í•¨ í˜„ì¬ ì•ˆì •ì ì´ì—ˆë˜ ì¸µìˆ˜ëŠ” stoneCount)
        if (currentSessionId) {
            supabaseClient
                .from('stone_towers')
                .update({ floor: stoneCount }) 
                .eq('id', currentSessionId)
                .then(() => {});
        }

        setTimeout(() => { 
            alert("ëŒíƒ‘ì´ ë¬´ë„ˆì¡ŒìŠµë‹ˆë‹¤! ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”."); 
            
            // 1. ê¸°ì¡´ ìŒ“ì¸ ëŒë“¤ ì œê±°
            stones.forEach(s => Composite.remove(engine.world, s));
            stones = [];
            
            // 2. ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” (ë‹‰ë„¤ì„ì€ ìœ ì§€)
            stoneCount = 0;
            isGameOver = false;
            document.getElementById('count').textContent = "1";
            updateEnvironment(1);
            
            // 3. ê¸°ë°˜ì„ ìƒˆë¡œ ìƒì„±í•˜ì—¬ ì¦‰ì‹œ ë‚™í•˜
            baseStone = Bodies.rectangle(gameWidth / 2, -50, 160, 50, { 
                friction: 10, 
                frictionStatic: 1000, 
                density: 200, 
                chamfer: { radius: 25 }, 
                label: 'baseStone', 
                isStatic: false, 
                emojiPair: { stable: "â—â—¡â—", unstable: "âŠ™ï½âŠ™" }, 
                render: { fillStyle: '#dcdcdc' } 
            });
            stones.push(baseStone);
            Composite.add(engine.world, baseStone);
            
            // [Supabase] ê¸°ë°˜ì„ ë“œë¡­(ì¬ì‹œì‘) ì‹œ íŠ¸ë¼ì´ ì¶”ê°€ ë° ìƒˆ ì„¸ì…˜ ì‹œì‘
            try {
                supabaseClient
                    .from('stone_towers')
                    .select('trial')
                    .eq('nickname', nickname)
                    .order('trial', { ascending: false })
                    .limit(1)
                    .then(({ data: trials }) => {
                        const nextTrial = (trials && trials.length > 0) ? trials[0].trial + 1 : 1;
                        return supabaseClient
                            .from('stone_towers')
                            .insert([{ nickname, trial: nextTrial, floor: 1, is_wish: 0 }])
                            .select();
                    })
                    .then(({ data }) => {
                        if (data && data.length > 0) currentSessionId = data[0].id;
                        loadGlobalStats();
                    });
            } catch (err) {}
            
            // 4. ë‹¤ìŒ ëŒ ì¤€ë¹„
            prepareNextStone();
        }, 800); 
    }

    async function renderLeaderboard() {
        const listEl = document.getElementById('leaderboard-list');
        if (!listEl) return;
        const wishText = document.getElementById('wish-text').value.trim();
        
        // 1) ë‚´ ì ìˆ˜ì™€ ì†Œì› ì—…ë°ì´íŠ¸
        if (currentSessionId) {
            try {
                await supabaseClient
                    .from('stone_towers')
                    .update({ floor: stoneCount + 1, wish: wishText, is_wish: 1 })
                    .eq('id', currentSessionId);
            } catch (err) {}
        }

        // 2) ë­í‚¹ ë°ì´í„° ì¡°íšŒ (ìµœëŒ€ 5ìœ„ê¹Œì§€ ì •ë³´ë§Œ í‘œì‹œ)
        try {
            const { data: rankData } = await supabaseClient
                .from('stone_towers')
                .select('id, nickname, floor')
                .eq('is_wish', 1)
                .order('floor', { ascending: false })
                .limit(5);

            if (rankData) {
                let html = `<table class="rank-table">
                    <thead><tr><th>ë“±ìˆ˜</th><th>ë‹‰ë„¤ì„</th><th>ì¸µìˆ˜</th></tr></thead>
                    <tbody>`;
                
                rankData.forEach((item, idx) => {
                    const isMyRow = (currentSessionId && item.id === currentSessionId);
                    let rankDisplay = (idx + 1) + "ìœ„";
                    if (idx === 0) rankDisplay = '<span class="rank-medal">ğŸ¥‡</span>';
                    else if (idx === 1) rankDisplay = '<span class="rank-medal">ğŸ¥ˆ</span>';
                    else if (idx === 2) rankDisplay = '<span class="rank-medal">ğŸ¥‰</span>';

                    html += `<tr class="rank-item ${isMyRow ? 'my-rank' : ''}">
                        <td>${rankDisplay}</td>
                        <td>${item.nickname}</td>
                        <td>${item.floor}ì¸µ</td>
                    </tr>`;
                });

                html += `</tbody></table>`;
                listEl.innerHTML = html;
            }
        } catch (err) {}
    }

    async function loadGlobalStats() {
        try {
            const { count, error } = await supabaseClient
                .from('stone_towers')
                .select('*', { count: 'exact', head: true });
            if (!error) {
                const el = document.getElementById('total-towers');
                if (el) el.textContent = String(count);
            }
        } catch (e) {}
    }

    let groundDeco = [];
    function initGroundDeco() {
        groundDeco = [];
        const colors = ['#2d3436', '#404040', '#4b4b4b', '#5d5d5d', '#353535'];
        const numStones = 35; // ê°œìˆ˜ ë” ëŠ˜ë¦¼
        const bOffset = (window.innerWidth <= 500 ? 120 : 100);
        for (let i = 0; i < numStones; i++) {
            const w = 80 + Math.random() * 80; // í¬ê¸° ë” ë‹¤ì–‘í•˜ê²Œ
            const h = w * (0.3 + Math.random() * 0.3);
            const x = Math.random() * (gameWidth + 100) - 50; // ì¢Œìš° ì—¬ë°±ê¹Œì§€ ì±„ì›€
            // ê¸°ë°˜ì„ ì•„ë˜ íšŒìƒ‰ ê³µê°„(bOffset ì˜ì—­)ì„ ì±„ìš°ë„ë¡ ë°°ì¹˜
            const groundTopY = gameHeight - bOffset + 25;
            const y = groundTopY + (Math.random() * bOffset); 
            const template = SHAPE_TEMPLATES[Math.floor(Math.random() * SHAPE_TEMPLATES.length)];
            const vertices = template.map(v => ({ x: v.x * w, y: v.y * h }));
            groundDeco.push({ x, y, vertices, color: colors[Math.floor(Math.random() * colors.length)], angle: (Math.random() - 0.5) * 1.0, pattern: ['sedimentary', 'basalt', 'granite'][Math.floor(Math.random() * 3)], seed: Math.random(), w, h });
        }
        // Yì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ë’¤ìª½ ëŒì´ ë¨¼ì € ê·¸ë ¤ì§€ê²Œ í•¨
        groundDeco.sort((a, b) => a.y - b.y);
    }

    function resetScreenHeight() { document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`); }
    function updateEnvironment(f) {
        const bg = document.getElementById('bg-layer');
        if (f <= 5) bg.style.backgroundImage = BG_IMAGES.level1;
        else if (f <= 10) bg.style.backgroundImage = BG_IMAGES.level2;
        else bg.style.backgroundImage = BG_IMAGES.level3;
    }
    function prepareNextStone() {
        const w = 110 + Math.random() * 40; const h = w * 0.6;
        const temp = SHAPE_TEMPLATES[Math.floor(Math.random() * SHAPE_TEMPLATES.length)];
        const sl = ["â—â—¡â—", "(â—'â—¡'â—)"]; if (Math.random() < 0.05) sl.push("/á ï½¡êˆï½¡áŸ\\");
        nextStoneData = { 
            w, h, vertices: temp.map(v => ({ x: v.x * w, y: v.y * h })), 
            pattern: ['sedimentary', 'basalt', 'granite'][Math.floor(Math.random() * 3)], seed: Math.random(),
            emojiPair: { stable: sl[Math.floor(Math.random() * sl.length)], unstable: ["âŠ™ï½âŠ™", "âŠ™ï¹âŠ™"][Math.floor(Math.random() * 2)] }
        };
        // 5ì¸µ ì´í›„(stoneCount >= 4)ì˜ ìƒì„± ìœ„ì¹˜ë¥¼ 150ì—ì„œ 250ìœ¼ë¡œ ë” ë‚®ì¶¤
        currentInputPos = { x: gameWidth / 2, y: (stoneCount < 4 ? 320 : 250) + targetCameraY };
    }
    function drawStonePattern(ctx, type, seed, w, h) {
        ctx.save();
        if (type === 'sedimentary') {
            ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.lineWidth = 3;
            for(let i = -h; i < h; i += 8) { ctx.beginPath(); ctx.moveTo(-w, i + (seed * 10)); ctx.lineTo(w, i + (seed * 10)); ctx.stroke(); }
        } else if (type === 'basalt') {
            ctx.fillStyle = 'rgba(0,0,0,0.18)';
            for(let i = 0; i < 12; i++) {
                const px = Math.sin(seed * i * 543) * (w * 0.4), py = Math.cos(seed * i * 123) * (h * 0.4);
                ctx.beginPath(); ctx.arc(px, py, 1 + (Math.abs(Math.sin(i)) * 4), 0, Math.PI * 2); ctx.fill();
            }
        } else if (type === 'granite') {
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            for(let i = 0; i < 25; i++) {
                const px = Math.cos(seed * i * 987) * (w * 0.45), py = Math.sin(seed * i * 456) * (h * 0.45);
                ctx.fillRect(px, py, 1 + (Math.abs(Math.sin(i * 2)) * 3), 1 + (Math.abs(Math.sin(i * 2)) * 3));
            }
        }
        ctx.restore();
    }

    const handleStart = (e) => {
        if (isWishFlow || !document.getElementById('game-page').classList.contains('active')) return;
        if (!isGameStarted || isGameOver || e.target.id === 'start-overlay') return;
        const x = e.touches ? e.touches[0].clientX : e.clientX, y = e.touches ? e.touches[0].clientY : e.clientY;
        const wr = document.getElementById('wish-btn').getBoundingClientRect();
        if (x > wr.left - 20 && x < wr.right + 20 && y > wr.top - 20 && y < wr.bottom + 20) return;
        if (stones.filter(s => !s.isStatic).length === 0) { isPressing = true; initialTouchX = x; initialTouchY = y; initialStoneX = currentInputPos.x; initialStoneY = currentInputPos.y; checkValidity(); }
    };
    const handleMove = (e) => {
        if (isWishFlow || !document.getElementById('game-page').classList.contains('active')) return;
        if (!isPressing) return;
        const x = e.touches ? e.touches[0].clientX : e.clientX, y = e.touches ? e.touches[0].clientY : e.clientY;
        currentInputPos.x = Math.max(50, Math.min(gameWidth - 50, initialStoneX + (x - initialTouchX)));
        currentInputPos.y = Math.max(targetCameraY + 50, Math.min(gameHeight - 250, initialStoneY + (y - initialTouchY)));
        checkValidity();
    };
    const handleEnd = () => {
        if (isWishFlow || !document.getElementById('game-page').classList.contains('active')) return;
        if (isPressing) { isPressing = false; if (isValidLocation) dropStone(); }
    };

    window.onload = () => {
        if (window.decomp) Common.setDecomp(window.decomp);
        resetScreenHeight(); initPhysics(); updateEnvironment(1);
        initGroundDeco();
        // [Supabase] ì „ì²´ ëŒíƒ‘ ëˆ„ì  íšŸìˆ˜ ë¡œë“œ
        loadGlobalStats();
        window.addEventListener('resize', resetScreenHeight);
        window.addEventListener('mousedown', handleStart);
        window.addEventListener('touchstart', (e) => {
            const onGamePage = document.getElementById('game-page').classList.contains('active');
            if (!onGamePage || isWishFlow) return;
            if (isGameStarted && e.target.id !== 'wish-btn') e.preventDefault();
            handleStart(e);
        }, { passive: false });
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', (e) => {
            const onGamePage = document.getElementById('game-page').classList.contains('active');
            if (!onGamePage || isWishFlow) return;
            if (isGameStarted) { e.preventDefault(); handleMove(e); }
        }, { passive: false });
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', (e) => { if(isGameStarted) handleEnd(); });
    };
</script>
</body>
</html>