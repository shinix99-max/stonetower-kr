<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ë§ˆìŒ ìŒ“ê¸° - ë””ì§€í„¸ ëŒíƒ‘</title>
    <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/dist/poly-decomp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        :root { --primary: #4a69bd; --bg: #0a0a0a; --text: #f0f2f5; }
        body { margin: 0; padding: 0; overflow: hidden; background: var(--bg); font-family: 'Pretendard', sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; touch-action: none; }
        
        #game-wrapper { 
            position: relative; width: 100%; max-width: 500px; height: 100vh;
            height: calc(var(--vh, 1vh) * 100); background: #0a0a0a; 
            overflow: hidden; display: flex; flex-direction: column;
        }

        @media (min-width: 501px) {
            #game-wrapper { height: 90vh; border-radius: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.8); }
        }
        
        #bg-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center; transition: background-image 1.5s ease-in-out; z-index: 1; opacity: 0.35; }

        .page { position: absolute; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; padding: 20px; box-sizing: border-box; z-index: 10; color: white; text-align: center; }
        .page.active { display: flex; }

        #landing-page { background: linear-gradient(to bottom, #1a1a1a, #0a0a0a); z-index: 60; }
        .logo { font-size: 42px; font-weight: 900; margin-bottom: 10px; color: #f5f5f5; text-shadow: 0 0 20px rgba(255,255,255,0.2); }
        .sub-logo { font-size: 16px; color: #ccc; margin-bottom: 40px; }
        .input-group { width: 80%; display: flex; flex-direction: column; gap: 15px; }
        input#nickname { padding: 18px; border-radius: 15px; border: 2px solid #333; background: #1a1a1a; color: white; font-size: 18px; text-align: center; outline: none; }
        .start-btn { background: var(--primary); color: white; padding: 18px; border-radius: 15px; border: none; font-weight: bold; font-size: 18px; cursor: pointer; }

        #game-page { padding: 0; cursor: default; background: transparent; overflow: hidden; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; }
        
        #wish-btn { 
            position: absolute; top: 30px; right: 30px; 
            background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 10px 20px; border-radius: 25px; 
            font-weight: bold; cursor: pointer; z-index: 30; backdrop-filter: blur(5px);
        }

        #info { position: absolute; top: 30px; left: 30px; pointer-events: none; z-index: 20; text-align: left; }
        .stats { font-size: 20px; font-weight: 800; color: white; text-shadow: 0 2px 5px rgba(0,0,0,0.7); }
        .guide-text { position: absolute; bottom: 50px; width: 100%; text-align: center; color: rgba(255,255,255,0.8); font-size: 15px; font-weight: 500; pointer-events: none; z-index: 20; text-shadow: 0 1px 2px rgba(0,0,0,0.4); }

        #wish-page { background: rgba(10, 10, 10, 0.9); z-index: 70; }
        textarea#wish-text { width: 90%; height: 180px; padding: 20px; border-radius: 20px; border: 2px solid #333; background: #1a1a1a; color: white; margin-bottom: 30px; resize: none; font-size: 18px; outline: none; box-sizing: border-box; }
        .submit-wish-btn { background: var(--primary); color: white; padding: 18px 40px; border-radius: 15px; border: none; font-weight: bold; font-size: 18px; cursor: pointer; width: 90%; }

        #result-page { background: #0a0a0a; overflow-y: auto; justify-content: flex-start; padding-top: 40px; padding-bottom: 40px; }
        .screenshot-container { width: 90%; height: 40vh; border-radius: 20px; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.5); margin-bottom: 20px; border: 1px solid #333; background: #1a1a1a; }
        #final-screenshot { width: 100%; height: 100%; object-fit: cover; object-position: bottom; display: block; }
        .cheer-msg { font-size: 20px; font-weight: 700; margin-bottom: 30px; color: #ddd; }
        .leaderboard { width: 80%; height: 40vh; background: #1a1a1a; border-radius: 20px; padding: 20px; margin-bottom: 40px; border: 1px solid #333; overflow-y: auto; box-sizing: border-box; }
        .rank-item { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #222; font-size: 16px; }

        #start-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.7); z-index: 25; cursor: pointer; }
        .start-text { font-size: 32px; font-weight: bold; color: white; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.05); opacity: 1; } 100% { transform: scale(1); opacity: 0.8; } }

        #moon-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.5); z-index: 100; pointer-events: none; }
        .moon-icon { font-size: 100px; filter: drop-shadow(0 0 30px rgba(255, 255, 200, 0.9)); transform: translateY(150px); opacity: 0; transition: all 2.5s cubic-bezier(0.25, 0.1, 0.25, 1); }
        .moon-icon.rising { transform: translateY(-100px); opacity: 1; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="bg-layer"></div>

    <section id="landing-page" class="page active">
        <h1 class="logo">ë§ˆìŒ ìŒ“ê¸°</h1>
        <p class="sub-logo">ë‹¹ì‹ ì˜ ì†Œì›ì„ ëŒíƒ‘ì— ë‹´ì•„ë³´ì„¸ìš”.</p>
        <p style="font-size: 14px; color: #aaa; margin-top: -28px; margin-bottom: 28px;">ì§€ê¸ˆê¹Œì§€ <span id="total-towers">0</span>ê°œì˜ ëŒíƒ‘ì´ ìŒ“ì˜€ì–´ìš”</p>
        <div class="input-group">
            <input type="text" id="nickname" placeholder="ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
            <button class="start-btn" onclick="goToGame()">ì‹œì‘í•˜ê¸°</button>
        </div>
    </section>

    <section id="game-page" class="page">
        <div id="moon-overlay">
            <div class="moon-icon">ğŸŒ•</div>
        </div>
        <button id="wish-btn" onclick="goToWish()">ì†Œì› ë¹Œê¸°</button>
        <div id="info">
            <div class="stats"><span id="user-nickname-display">ìœ ì €</span>ë‹˜ì˜ ëŒíƒ‘</div>
            <div class="stats"><span id="count">1</span>ì¸µ</div>
        </div>
        <div id="start-overlay" onclick="startGame(event)">
            <div class="start-text">í„°ì¹˜í•˜ì—¬ ì‹œì‘</div>
            <p style="font-size: 14px; color: #aaa; margin-top: 20px;">* ì†Œì› ë¹Œê¸°ë¥¼ ëˆ„ë¥´ë©´ ë‹¤ì‹œ ìŒ“ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
        </div>
        <div id="canvas-container"></div>
        <div class="guide-text">ì›í•˜ëŠ” ìœ„ì¹˜ë¡œ ëŒì–´ì„œ ë†“ìœ¼ì„¸ìš”.</div>
    </section>

    <section id="wish-page" class="page">
        <h2>ì†Œì› ì ê¸°</h2>
        <textarea id="wish-text" placeholder="ì—¬ê¸°ì— ì†Œì›ì„ ì ì–´ì£¼ì„¸ìš”..."></textarea>
        <button class="submit-wish-btn" onclick="finishGame()">ì†Œì› ì €ì¥í•˜ê³  ê²°ê³¼ ë³´ê¸°</button>
    </section>

    <section id="result-page" class="page">
        <div class="screenshot-container">
            <img id="final-screenshot" src="" alt="ë‚˜ì˜ ëŒíƒ‘">
        </div>
        <p class="cheer-msg">ë‹¹ì‹ ì˜ ì†Œì›ì´<br>ê¼­ ì´ë£¨ì–´ì§€ê¸¸ ë°”ëë‹ˆëŒ.<br><br><span style="font-size: 16px; opacity: 0.8;">- ëŒë©©ì´ ì¼ë™ -</span></p>
        <div class="leaderboard">
            <h3>ë‹¤ë¥¸ ì‚¬ëŒë“¤ì˜ ë§ˆìŒ</h3>
            <div id="leaderboard-list"></div>
        </div>
        <button class="retry-btn" style="margin-top: 40px; background: none; color: #666; border: none; text-decoration: underline;" onclick="location.reload()">ë‹¤ì‹œ ì‹œì‘í•˜ê¸°</button>
    </section>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Body, Events, Bounds, Vertices, SAT, Query, Common } = Matter;

    // Supabase ì„¤ì •
    const SUPABASE_URL = 'https://getubkgxtccbmxypwkui.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdldHVia2d4dGNjYm14eXB3a3VpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjcwODMwNTcsImV4cCI6MjA4MjY1OTA1N30.GiGrkY1V27PluiWG6BL7dNLOK4U-XJruq0SDl1dV5Ho';
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    let currentSessionId = null; // í˜„ì¬ íŒì˜ DB IDë¥¼ ì €ì¥

    const BG_IMAGES = {
        level1: 'url("./low_background_3.png")', 
        level2: 'url("./middle_background_3.png")', 
        level3: 'url("./high_background_3.png")'   
    };

    const SHAPE_TEMPLATES = [
        [{x: -0.55, y: 0}, {x: -0.5, y: -0.15}, {x: -0.3, y: -0.22}, {x: 0, y: -0.25}, {x: 0.3, y: -0.22}, {x: 0.5, y: -0.15}, {x: 0.55, y: 0}, {x: 0.5, y: 0.15}, {x: 0.3, y: 0.22}, {x: 0, y: 0.25}, {x: -0.3, y: 0.22}, {x: -0.5, y: 0.15}, {x: -0.55, y: 0.05}],
        [{x: -0.45, y: 0}, {x: -0.4, y: -0.18}, {x: -0.1, y: -0.25}, {x: 0.2, y: -0.24}, {x: 0.5, y: -0.15}, {x: 0.55, y: 0.05}, {x: 0.45, y: 0.2}, {x: 0.1, y: 0.25}, {x: -0.2, y: 0.23}, {x: -0.4, y: 0.15}],
        [{x: -0.4, y: 0.05}, {x: -0.35, y: -0.15}, {x: -0.15, y: -0.23}, {x: 0.15, y: -0.23}, {x: 0.35, y: -0.15}, {x: 0.4, y: 0.05}, {x: 0.35, y: 0.22}, {x: 0.1, y: 0.25}, {x: -0.1, y: 0.25}, {x: -0.35, y: 0.22}],
        [{x: -0.5, y: 0.05}, {x: -0.45, y: -0.12}, {x: -0.1, y: -0.25}, {x: 0.3, y: -0.22}, {x: 0.52, y: -0.05}, {x: 0.48, y: 0.18}, {x: 0.2, y: 0.25}, {x: -0.15, y: 0.24}, {x: -0.4, y: 0.18}],
        [{x: -0.58, y: -0.05}, {x: -0.5, y: -0.22}, {x: 0, y: -0.25}, {x: 0.5, y: -0.22}, {x: 0.58, y: -0.05}, {x: 0.55, y: 0.18}, {x: 0, y: 0.25}, {x: -0.55, y: 0.18}]
    ];

    let engine, render, runner, ground, baseStone;
    let nickname = ""; let stoneCount = 0;
    let isGameOver = false; let isGameStarted = false; let stones = [];
    let isPressing = false; let isValidLocation = true;    
    let initialTouchX = 0; let initialTouchY = 0;
    let initialStoneX = 0; let initialStoneY = 0;
    let cameraY = 0; let targetCameraY = 0;
    let gameWidth = 450; let gameHeight = 800;
    let nextStoneData = { w: 0, h: 0 };
    let currentInputPos = { x: 225, y: 320 };
    let isWishFlow = false; // ì†Œì› ë¹Œê¸° ì´í›„: ê²Œì„ ì…ë ¥(í„°ì¹˜) ì°¨ë‹¨ìš©

    // ì „ì—­ í•¨ìˆ˜ ë“±ë¡
    window.showPage = (id) => {
        document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
        document.getElementById(id).classList.add('active');
    };

    window.goToGame = () => {
        const input = document.getElementById('nickname');
        if (!input.value.trim()) { alert("ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!"); return; }
        nickname = input.value.trim();
        document.getElementById('user-nickname-display').textContent = nickname;
        window.showPage('game-page');
    };

    window.startGame = async (e) => {
        if (e) { e.stopPropagation(); e.preventDefault(); }
        if (isGameStarted) return;
        isGameStarted = true;
        document.getElementById('start-overlay').style.display = 'none';
        
        // [Supabase] ê¸°ë°˜ì„ ë“œë¡­(ê²Œì„ ì‹œì‘) íšŸìˆ˜ ì§‘ê³„ ë° ì„¸ì…˜ ì‹œì‘
        try {
            const { data: trials } = await supabaseClient
                .from('stone_towers')
                .select('trial')
                .eq('nickname', nickname)
                .order('trial', { ascending: false })
                .limit(1);
            
            const nextTrial = (trials && trials.length > 0) ? trials[0].trial + 1 : 1;
            
            const { data } = await supabaseClient
                .from('stone_towers')
                .insert([{ nickname, trial: nextTrial, floor: 1 }])
                .select();
            
            if (data && data.length > 0) currentSessionId = data[0].id;
            loadGlobalStats();
        } catch (err) {}

        Body.setStatic(baseStone, false);
        prepareNextStone();
    };

    window.goToWish = async () => {
        isWishFlow = true;
        isPressing = false;
        const btn = document.getElementById('wish-btn');
        if (btn) { btn.disabled = true; btn.style.opacity = '0.5'; }
        
        const moon = document.getElementById('moon-overlay');
        if (moon) {
            moon.style.display = 'flex';
            setTimeout(() => moon.querySelector('.moon-icon').classList.add('rising'), 50);
        }

        // í˜ì´ì§€ ì „í™˜ì„ ë¨¼ì € ì§„í–‰í•˜ì—¬ ì‚¬ìš©ì ì²´ê° ê°œì„ 
        setTimeout(() => {
            window.showPage('wish-page');
            captureFinalTower(); // ìº¡ì²˜ëŠ” ë°°ê²½ì—ì„œ ì§„í–‰
        }, 2500);
    };

    window.finishGame = () => {
        if (!document.getElementById('wish-text').value.trim()) { alert("ì†Œì›ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!"); return; }
        renderLeaderboard(); window.showPage('result-page');
    };

    function captureFinalTower() {
        const matterCanvas = document.querySelector('#canvas-container canvas');
        const bgLayer = document.getElementById('bg-layer');
        const finalImg = document.getElementById('final-screenshot');
        if (!matterCanvas || !bgLayer || !finalImg) return;

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = matterCanvas.width; tempCanvas.height = matterCanvas.height;
        const ctx = tempCanvas.getContext('2d');
        
        const bgUrl = bgLayer.style.backgroundImage.replace(/url\(['"]?(.*?)['"]?\)/i, '$1');
        const renderImg = (bg) => {
            ctx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            if (bg) {
                const cR = tempCanvas.width / tempCanvas.height;
                const iR = bg.width / bg.height;
                let dw, dh, ox, oy;
                if (cR > iR) { dw = tempCanvas.width; dh = tempCanvas.width / iR; ox = 0; oy = (tempCanvas.height - dh) / 2; }
                else { dw = tempCanvas.height * iR; dh = tempCanvas.height; ox = (tempCanvas.width - dw) / 2; oy = 0; }
                ctx.save(); ctx.globalAlpha = 0.35; ctx.drawImage(bg, ox, oy, dw, dh); ctx.restore();
            }
            const bOffset = (window.innerWidth <= 500) ? 200 : 150;
            const bBottomY = gameHeight - bOffset + 25;
            const scale = tempCanvas.height / bBottomY;
            const destW = gameWidth * scale;
            ctx.drawImage(matterCanvas, 0, 0, gameWidth, bBottomY, (tempCanvas.width - destW) / 2, 0, destW, tempCanvas.height);
            finalImg.src = tempCanvas.toDataURL('image/png');
        };

        if (bgUrl && bgUrl !== 'none') {
            const img = new Image(); img.crossOrigin = "anonymous";
            img.onload = () => renderImg(img); img.onerror = () => renderImg(null); img.src = bgUrl;
        } else renderImg(null);
    }

    function initPhysics() {
        const container = document.getElementById('canvas-container');
        const isMobile = window.innerWidth <= 500;
        gameWidth = isMobile ? window.innerWidth : 500;
        gameHeight = isMobile ? window.innerHeight : window.innerHeight * 0.9;
        engine = Engine.create({ constraintIterations: 50, positionIterations: 50, velocityIterations: 50 });
        engine.world.gravity.y = 1.2;
        render = Render.create({ element: container, engine, options: { width: gameWidth, height: gameHeight, wireframes: false, background: 'transparent', hasBounds: true } });
        
        // [ìˆ˜ì •] ë°”ë‹¥ íšŒìƒ‰ ì˜ì—­ ë†’ì´ë¥¼ ë‹¤ì‹œ ì¤„ì„ (200/150 -> 120/100)
        const bOffset = isMobile ? 120 : 100;
        ground = Bodies.rectangle(gameWidth / 2, gameHeight + 50 - (bOffset - 25), gameWidth, bOffset + 100, { isStatic: true, label: 'ground', render: { fillStyle: '#333' } });
        baseStone = Bodies.rectangle(gameWidth / 2, -50, 160, 50, { friction: 10, frictionStatic: 1000, density: 200, chamfer: { radius: 25 }, label: 'baseStone', isStatic: true, emojiPair: { stable: "â—â—¡â—", unstable: "âŠ™ï½âŠ™" }, render: { fillStyle: '#dcdcdc' } });
        stones.push(baseStone); Composite.add(engine.world, [ground, baseStone]);
        
        Events.on(render, 'beforeRender', () => { cameraY += (targetCameraY - cameraY) * 0.05; Bounds.shift(render.bounds, { x: 0, y: cameraY }); });
        Events.on(render, 'afterRender', () => {
            const ctx = render.context; const now = Date.now();
            ctx.save(); ctx.translate(-render.bounds.min.x, -render.bounds.min.y);
            if (isGameStarted && !isGameOver && isPressing && stones.filter(s => !s.isStatic).length === 0) {
                ctx.save(); ctx.translate(currentInputPos.x, currentInputPos.y); ctx.globalAlpha = 0.6; ctx.fillStyle = isValidLocation ? '#f5f5f5' : '#ff7675';
                ctx.beginPath(); nextStoneData.vertices.forEach((v, i) => i === 0 ? ctx.moveTo(v.x, v.y) : ctx.lineTo(v.x, v.y)); ctx.closePath(); ctx.fill();
                if (nextStoneData.pattern) { ctx.save(); ctx.clip(); drawStonePattern(ctx, nextStoneData.pattern, nextStoneData.seed, nextStoneData.w, nextStoneData.h); ctx.restore(); }
                ctx.fillStyle = '#333'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.fillText(nextStoneData.emojiPair.stable, 0, 5);
                ctx.globalAlpha = 1; ctx.font = '35px Arial'; ctx.fillText('ğŸ‘†', nextStoneData.w / 2, 20); ctx.restore();
            }
            [ground, ...stones].forEach(body => {
                const { x, y } = body.position;
                // [ìˆ˜ì •] ê¸°ë°˜ì„ ë©ˆì¶¤ ìœ„ì¹˜ë„ bOffsetì— ë§ì¶° ìˆ˜ì •
                const currentBOffset = (window.innerWidth <= 500) ? 120 : 100;
                const stopY = gameHeight - currentBOffset;
                if (body.label === 'baseStone' && !body.isStatic && y >= stopY) { Body.setStatic(body, true); Body.setPosition(body, { x: gameWidth / 2, y: stopY }); }
                if (!body.isStatic) { if (body.speed < 0.3 && body.angularSpeed < 0.05) { if (!body.stableStartTime) body.stableStartTime = now; else if (now - body.stableStartTime > 600) Body.setStatic(body, true); } else body.stableStartTime = null; }
                ctx.save();
                if (body.render.fillStyle === 'rainbow') { const h = (now / 30) % 360; ctx.fillStyle = `hsl(${h}, 80%, 70%)`; ctx.shadowColor = `hsl(${h}, 80%, 70%)`; ctx.shadowBlur = 15; }
                else ctx.fillStyle = body.render.fillStyle;
                (body.parts.length > 1 ? body.parts.slice(1) : [body]).forEach(p => { ctx.beginPath(); p.vertices.forEach((v, i) => i === 0 ? ctx.moveTo(v.x, v.y) : ctx.lineTo(v.x, v.y)); ctx.closePath(); ctx.fill(); });
                if (body.patternType && body.patternType !== 'rainbow') {
                    ctx.save(); ctx.translate(x, y); ctx.rotate(body.angle); ctx.beginPath();
                    (body.parts.length > 1 ? body.parts[1].vertices : body.vertices).forEach((v, i) => { const lx = v.x-x, ly = v.y-y, cos = Math.cos(-body.angle), sin = Math.sin(-body.angle); i === 0 ? ctx.moveTo(lx*cos-ly*sin, lx*sin+ly*cos) : ctx.lineTo(lx*cos-ly*sin, lx*sin+ly*cos); });
                    ctx.closePath(); ctx.clip(); drawStonePattern(ctx, body.patternType, body.patternSeed, body.bounds.max.x-body.bounds.min.x, body.bounds.max.y-body.bounds.min.y); ctx.restore();
                }
                ctx.restore();
                if (body.label !== 'ground') {
                    ctx.save(); ctx.translate(x, y); ctx.rotate(body.angle);
                    ctx.fillStyle = body.render.fillStyle === 'rainbow' ? '#fff' : (body.render.fillStyle === '#404040' || body.render.fillStyle === '#707070' ? '#ddd' : '#333');
                    ctx.textAlign = 'center'; ctx.font = 'bold 20px Arial'; ctx.fillText(body.emojiPair ? (body.speed < 0.3 ? body.emojiPair.stable : body.emojiPair.unstable) : 'â—â—¡â—', 0, 5); ctx.restore();
                }
            });
            ctx.restore();
        });
        Events.on(engine, 'collisionStart', (e) => { e.pairs.forEach(p => { if (((stones.includes(p.bodyA) && !p.bodyA.isStatic) || (stones.includes(p.bodyB) && !p.bodyB.isStatic)) && p.bodyA !== ground && p.bodyB !== ground && p.bodyA.label !== 'baseStone' && p.bodyB.label !== 'baseStone') stones.forEach(s => { if(s.isStatic && s.label !== 'baseStone') Body.setStatic(s, false); }); if ((p.bodyA === ground || p.bodyB === ground) && !isGameOver && (p.bodyA.label === 'stone' || p.bodyB.label === 'stone')) gameOver(); }); });
        runner = Runner.create(); Runner.run(runner, engine); Render.run(render);
    }

    function checkValidity() {
        const temp = Bodies.fromVertices(currentInputPos.x, currentInputPos.y, [nextStoneData.vertices.map(v => ({ x: v.x + currentInputPos.x, y: v.y + currentInputPos.y }))]);
        if (!temp) { isValidLocation = true; return; }
        isValidLocation = !Query.region(stones, temp.bounds).some(o => SAT.collides(temp, o).collided);
    }

    function dropStone() {
        const r = Math.random(); const c = r < 0.24 ? '#f5f5f5' : (r < 0.48 ? '#b0b0b0' : (r < 0.72 ? '#707070' : (r < 0.95 ? '#404040' : 'rainbow')));
        const s = Bodies.fromVertices(currentInputPos.x, currentInputPos.y, [Vertices.create(nextStoneData.vertices)], { friction: 10, frictionStatic: 1000, restitution: 0, density: 100, label: 'stone', patternType: nextStoneData.pattern, patternSeed: nextStoneData.seed, emojiPair: c === 'rainbow' ? { stable: 'âœª Ï‰ âœª', unstable: 'âœª Ï‰ âœª' } : nextStoneData.emojiPair, render: { fillStyle: c, visible: false } }, true, 0.01, 10, 0.01);
        if (!s) return; stones.push(s); Composite.add(engine.world, s); stoneCount++; document.getElementById('count').textContent = stoneCount + 1; updateEnvironment(stoneCount + 1); prepareNextStone();
    }

    function gameOver() { 
        if (isGameOver) return; 
        isGameOver = true; 
        isPressing = false; 
        setTimeout(() => { 
            alert("ëŒíƒ‘ì´ ë¬´ë„ˆì¡ŒìŠµë‹ˆë‹¤! ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”."); 
            
            // 1. ê¸°ì¡´ ìŒ“ì¸ ëŒë“¤ ì œê±°
            stones.forEach(s => Composite.remove(engine.world, s));
            stones = [];
            
            // 2. ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” (ë‹‰ë„¤ì„ì€ ìœ ì§€)
            stoneCount = 0;
            isGameOver = false;
            document.getElementById('count').textContent = "1";
            updateEnvironment(1);
            
            // 3. ê¸°ë°˜ì„ ìƒˆë¡œ ìƒì„±í•˜ì—¬ ì¦‰ì‹œ ë‚™í•˜
            baseStone = Bodies.rectangle(gameWidth / 2, -50, 160, 50, { 
                friction: 10, 
                frictionStatic: 1000, 
                density: 200, 
                chamfer: { radius: 25 }, 
                label: 'baseStone', 
                isStatic: false, 
                emojiPair: { stable: "â—â—¡â—", unstable: "âŠ™ï½âŠ™" }, 
                render: { fillStyle: '#dcdcdc' } 
            });
            stones.push(baseStone);
            Composite.add(engine.world, baseStone);
            
            // [Supabase] ê¸°ë°˜ì„ ë“œë¡­(ì¬ì‹œì‘) ì‹œ íŠ¸ë¼ì´ ì¶”ê°€
            try {
                supabaseClient
                    .from('stone_towers')
                    .select('trial')
                    .eq('nickname', nickname)
                    .order('trial', { ascending: false })
                    .limit(1)
                    .then(({ data: trials }) => {
                        const nextTrial = (trials && trials.length > 0) ? trials[0].trial + 1 : 1;
                        return supabaseClient
                            .from('stone_towers')
                            .insert([{ nickname, trial: nextTrial, floor: 1 }])
                            .select();
                    })
                    .then(({ data }) => {
                        if (data && data.length > 0) currentSessionId = data[0].id;
                        loadGlobalStats();
                    });
            } catch (err) {}
            
            // 4. ë‹¤ìŒ ëŒ ì¤€ë¹„
            prepareNextStone();
        }, 800); 
    }

    async function renderLeaderboard() {
        const listEl = document.getElementById('leaderboard-list');
        if (!listEl) return;
        const wishText = document.getElementById('wish-text').value.trim();
        
        // 1) ë‚´ ì ìˆ˜ì™€ ì†Œì› ì—…ë°ì´íŠ¸
        if (currentSessionId) {
            try {
                await supabaseClient
                    .from('stone_towers')
                    .update({ floor: stoneCount + 1, wish: wishText })
                    .eq('id', currentSessionId);
            } catch (err) {}
        }

        // 2) Top3 ì¡°íšŒ (ê°€ì¥ ë†’ì€ ì¸µìˆ˜ ê¸°ì¤€)
        try {
            const { data: topData } = await supabaseClient
                .from('stone_towers')
                .select('nickname, floor')
                .order('floor', { ascending: false })
                .limit(3);

            if (topData) {
                listEl.innerHTML = topData.map((item, idx) => {
                    return `<div class="rank-item"><span>${idx + 1}ìœ„ / ${item.nickname}</span><span>${item.floor}ì¸µ</span></div>`;
                }).join('');
            }
        } catch (err) {}
    }

    async function loadGlobalStats() {
        try {
            const { count, error } = await supabaseClient
                .from('stone_towers')
                .select('*', { count: 'exact', head: true });
            if (!error) {
                const el = document.getElementById('total-towers');
                if (el) el.textContent = String(count);
            }
        } catch (e) {}
    }

    function resetScreenHeight() { document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`); }
    function updateEnvironment(f) {
        const bg = document.getElementById('bg-layer');
        if (f <= 5) bg.style.backgroundImage = BG_IMAGES.level1;
        else if (f <= 10) bg.style.backgroundImage = BG_IMAGES.level2;
        else bg.style.backgroundImage = BG_IMAGES.level3;
    }
    function prepareNextStone() {
        const w = 110 + Math.random() * 40; const h = w * 0.6;
        const temp = SHAPE_TEMPLATES[Math.floor(Math.random() * SHAPE_TEMPLATES.length)];
        const sl = ["â—â—¡â—", "(â—'â—¡'â—)"]; if (Math.random() < 0.05) sl.push("/á ï½¡êˆï½¡áŸ\\");
        nextStoneData = { 
            w, h, vertices: temp.map(v => ({ x: v.x * w, y: v.y * h })), 
            pattern: ['sedimentary', 'basalt', 'granite'][Math.floor(Math.random() * 3)], seed: Math.random(),
            emojiPair: { stable: sl[Math.floor(Math.random() * sl.length)], unstable: ["âŠ™ï½âŠ™", "âŠ™ï¹âŠ™"][Math.floor(Math.random() * 2)] }
        };
        currentInputPos = { x: gameWidth / 2, y: (stoneCount < 4 ? 320 : 150) + targetCameraY };
    }
    function drawStonePattern(ctx, type, seed, w, h) {
        ctx.save();
        if (type === 'sedimentary') {
            ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.lineWidth = 3;
            for(let i = -h; i < h; i += 8) { ctx.beginPath(); ctx.moveTo(-w, i + (seed * 10)); ctx.lineTo(w, i + (seed * 10)); ctx.stroke(); }
        } else if (type === 'basalt') {
            ctx.fillStyle = 'rgba(0,0,0,0.18)';
            for(let i = 0; i < 12; i++) {
                const px = Math.sin(seed * i * 543) * (w * 0.4), py = Math.cos(seed * i * 123) * (h * 0.4);
                ctx.beginPath(); ctx.arc(px, py, 1 + (Math.abs(Math.sin(i)) * 4), 0, Math.PI * 2); ctx.fill();
            }
        } else if (type === 'granite') {
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            for(let i = 0; i < 25; i++) {
                const px = Math.cos(seed * i * 987) * (w * 0.45), py = Math.sin(seed * i * 456) * (h * 0.45);
                ctx.fillRect(px, py, 1 + (Math.abs(Math.sin(i * 2)) * 3), 1 + (Math.abs(Math.sin(i * 2)) * 3));
            }
        }
        ctx.restore();
    }

    const handleStart = (e) => {
        if (isWishFlow || !document.getElementById('game-page').classList.contains('active')) return;
        if (!isGameStarted || isGameOver || e.target.id === 'start-overlay') return;
        const x = e.touches ? e.touches[0].clientX : e.clientX, y = e.touches ? e.touches[0].clientY : e.clientY;
        const wr = document.getElementById('wish-btn').getBoundingClientRect();
        if (x > wr.left - 20 && x < wr.right + 20 && y > wr.top - 20 && y < wr.bottom + 20) return;
        if (stones.filter(s => !s.isStatic).length === 0) { isPressing = true; initialTouchX = x; initialTouchY = y; initialStoneX = currentInputPos.x; initialStoneY = currentInputPos.y; checkValidity(); }
    };
    const handleMove = (e) => {
        if (isWishFlow || !document.getElementById('game-page').classList.contains('active')) return;
        if (!isPressing) return;
        const x = e.touches ? e.touches[0].clientX : e.clientX, y = e.touches ? e.touches[0].clientY : e.clientY;
        currentInputPos.x = Math.max(50, Math.min(gameWidth - 50, initialStoneX + (x - initialTouchX)));
        currentInputPos.y = Math.max(targetCameraY + 50, Math.min(gameHeight - 250, initialStoneY + (y - initialTouchY)));
        checkValidity();
    };
    const handleEnd = () => {
        if (isWishFlow || !document.getElementById('game-page').classList.contains('active')) return;
        if (isPressing) { isPressing = false; if (isValidLocation) dropStone(); }
    };

    window.onload = () => {
        if (window.decomp) Common.setDecomp(window.decomp);
        resetScreenHeight(); initPhysics(); updateEnvironment(1);
        // [Supabase] ì „ì²´ ëŒíƒ‘ ëˆ„ì  íšŸìˆ˜ ë¡œë“œ
        loadGlobalStats();
        window.addEventListener('resize', resetScreenHeight);
        window.addEventListener('mousedown', handleStart);
        window.addEventListener('touchstart', (e) => {
            const onGamePage = document.getElementById('game-page').classList.contains('active');
            if (!onGamePage || isWishFlow) return;
            if (isGameStarted && e.target.id !== 'wish-btn') e.preventDefault();
            handleStart(e);
        }, { passive: false });
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', (e) => {
            const onGamePage = document.getElementById('game-page').classList.contains('active');
            if (!onGamePage || isWishFlow) return;
            if (isGameStarted) { e.preventDefault(); handleMove(e); }
        }, { passive: false });
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', (e) => { if(isGameStarted) handleEnd(); });
    };
</script>
</body>
</html>